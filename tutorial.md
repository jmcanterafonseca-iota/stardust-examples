# Stardust for iota.js developers : Part I Value Transactions

This series of how-to pages is intended to Javascript developers that want to get familiar with:

* the structure and functionality of transactions in Stardust (the IOTA protocol version that enables the Shimmer network)
* iota.js primitives to issue those transactions

## Introduction

Starting from Chrysalis, IOTA is a UTXO-based (Unspent Transaction Output) Ledger. Each UTXO, aka output, has an associated number of tokens that determines its value. Thus, the permanent data on the ledger is composed by a set of records (*outputs*) that can be unlocked by whoever has the right to do it, usually the one who knows a certain private key of an address.  There can be different types of outputs as explained [here](), but in this tutorial we will only talk about traditional value outputs. Outputs are generated by transactions that unlock and consume existing outputs (which actually turn into inputs when consumed by a transaction) and generate new outputs. At pruning time consumed outputs will be removed by Nodes. However they might be stored permanently by Nodes counting with an INX Chronicle plugin. Each output in the Ledger has a unique identifier as it has each transaction.

## Storage cost

UTXOs need to be stored by Hornet Nodes, thus there is a storage cost. The Stardust protocol defines a parameter, named "vByte cost", that defines, in *Glows*, the cost of storage of each "virtual byte". As each output consumes a number of vBytes in the Ledger, it is a necessary condition for an output to cover with its value at least the vByte cost in the Ledger. This means that Nodes will reject, upfront, transactions which outputs do not meet this condition. For instance, in the current Shimmer network, you cannot just transact 1 Glow to a new output because the storage cost of such an output will be higher. And that's when it comes into play *storage deposits* that will be introduced later on.

The size of a UTXO and thus its cost depends structurally on its type but also on additional data it may carry out as we will be showing lately.

## Preparing the experimentation environment

In order to run a similar code than the one explained by this tutorial you need:

* Node.js 16
* The `@iota/iota.js` library package, version xx.
* Auxiliary libraries, `@iota/crypto.js` `@iota/util.js`
* Access to a Stardust Node (Hornet 2.0.0), for instance, the Shimmer testnet Nodes at []().
* To run the PoW computation it would be advisable to count with the Neon-Pow package. Another alternative is that you spin out your own Node configured to perform the PoW remotely.
* If you decide to use TypeScript then also the TypeScript compiler and so on

An example `package.json` file is shown below:

```json
{
    "name": "tutorial",
    "version": "1.0.0",
    "scripts": {
        "dist": "tsc",
        "start": "node dist/index"
    },
    "dependencies": {
        "@iota/crypto.js": "2.0.0-rc.1",
        "@iota/iota.js": "2.0.0-rc.1",
        "@iota/util.js": "2.0.0-rc.1",
        "@iota/pow-neon.js": "2.0.0-rc.2"
    },
    "devDependencies": {
        "typescript": "^4.4.3",
        "@types/node": "18.7.23"
    }
}
```

## Generating addresses

In order to start transacting in the network it is needed to count with one or more addresses that can unlock outputs or receive new outputs. Addresses are derived from a public key and their outputs can be unlocked with the corresponding private key. As it happens with Firefly the idea is to be able to generate multiple addresses starting with an initial master secret (seed phrase) and from that point on use a hierarchical deterministic method to derive the different addresses.

### Generating a seed phrase and an Ed25519 seed

```typescript
    // Default entropy length is 256
    const randomMnemonic = Bip39.randomMnemonic();

    console.log("Seed phrase:", randomMnemonic);
```

The seed phrase is generated in accordance with the [Bip 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) specification and it is composed by a set of words, represented as whitespace-separated string.

Once you have the seed phrase the next step is to obtain a Ed25519 seed from the seed phrase:

```typescript
 const baseSeed = Ed25519Seed.fromMnemonic(randomMnemonic);
```

This base seed will be used later to generate the Ed25519 key pairs through the address paths.

### Deterministic address paths (Bip32)

This base seed can be used to generate, in a deterministic manner, addresses i.e. Ed25519 key pairs, using [Bip44]() convention which it is based on [Bip32]() paths. The iota.js library provides a method `generateBip44Address` that creates these paths using an state object that it is updated on each call made.

```typescript
const addressGeneratorAccountState = {
    accountIndex: 0,
    addressIndex: 0,
    isInternal: false
};
const paths: string[] = [];
for (let i = 0; i < 6; i++) {
    const path = generateBip44Address(addressGeneratorAccountState);
    paths.put(path);

    console.log(`${path}`);
}
```

That will generate the following Bip32 paths:

```text
m/44'/4218'/0'/0'/0'
m/44'/4218'/0'/1'/0'
m/44'/4218'/0'/0'/1'
m/44'/4218'/0'/1'/1'
m/44'/4218'/0'/0'/2'
m/44'/4218'/0'/1'/2'
```

* `44` is a constant that denotes *purpose*, (`0x8000002C`) following the BIP43 recommendation.
* `4218` is the *coin type* for Shimmer
* the three following numbers are:

* the *account index*, as users can use these accounts to organize the funds in the same fashion as bank accounts; for donation purposes (where all addresses are considered public), for saving purposes, for common expenses etc.
* the *change index*, that allows to separate addresses used for external operations or just for internal operations
* the *address index* that increments sequentially

In the example above it has been generated `6` address paths, for the account `0` and from index `0` to `2`, starting with one address for external operations and then alternating with one address for internal operations.

### Ed25519 key pairs for the addresses

For generating a Ed25519 key fair first off all it is needed to generate a subsequent seed from a Bip32 path and from that point on the key pair can be derived.

```typescript
const keyPairs: IKeyPair[] = [];

for (const path of paths) {
    const addressSeed = baseSeed.generateSeedFromPath(new Bip32Path(path));
    const addressKeyPair = addressSeed.keyPair();
    keyPairs.push(addressKeyPair);

    console.log(Converter.bytesToHex(addressKeyPair.privateKey, true));
    console.log(Converter.bytesToHex(addressKeyPair.publicKey, true));
}
```

For instance

`0x6f0fa2f7a9d5fbd221c20f54d944378acb871dcdeafc3761e73d7f0aa05c75356f8eeee559daa287ec40a3a7113e88df2fc27bc77819e6d3d146a7dc7a4e939c`
`0x6f8eeee559daa287ec40a3a7113e88df2fc27bc77819e6d3d146a7dc7a4e939c`

You can see the the Ed25519 private key contains 128 hex chars that corresponds to 64 bytes. Conversely, the public key can be represented using 64 hex chars i.e. 32 bytes.

At this point in time we have our asymmetric cryptography set but we need to generate the final address that will be used in the Shimmer network.

## Final addresses

As it usually happens in Blockchain the addresses used are derived from a public key by hashing it. In the case of Stardust, they are derived from the Ed25519 public key.

There are two different address formats named as the Ed25519 format (which it is just a hash of the Ed25519 public key) and a more readable format which complies with [Bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki). In the case of Shimmer the Bech32 human readable part (HRP) used is `smr` whereas `rms` is used for the testnet. Those values are also provided as part of the info primitive of the protocol (more on this later)

```typescript
for (const keyPair of keyPairs) {
    const ed25519Address = new Ed25519Address(keyPair.publicKey);
    // Address in bytes
    const publicKeyAddress = ed25519Address.toAddress();

    const bech32Addr = Bech32Helper.toBech32(ED25519_ADDRESS_TYPE, publicKeyAddress, "rms");

    const finalAddress = {
        ed25519: Converter.bytesToHex(publicKeyAddress, true),
        bech32: bech32Addr
    };
    finalAddresses.push(finalAddress);

    console.log(finalAddress);
}
```

Resulting in:

```text
{
  ed25519: '0x1696e3735e8871ce7086af6a9920e1a3b83cdf8b265adf449fc4bda86b91e2bb',
  bech32: 'rms1qqtfdcmnt6y8rnnss6hk4xfqux3ms0xl3vn94h6ynlztm2rtj83tk9qkzrx'
}
```
