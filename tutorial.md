# Stardust for iota.js developers : Part I Value Transactions

This series of how-to pages is intended to Javascript developers that want to get familiar with:

* the structure and functionality of transactions in Stardust (the IOTA protocol version that enables the Shimmer network)
* iota.js primitives to issue those transactions

## Introduction

Starting from Chrysalis, IOTA is a UTXO-based (Unspent Transaction Output) Ledger. Each UTXO, aka output, has an associated number of tokens that determines its value. Thus, the permanent data on the ledger is composed by a set of records (*outputs*) that can be unlocked by whoever has the right to do it, usually the one who knows a certain private key of an address.  There can be different types of outputs as explained [here](), but in this tutorial we will only talk about traditional value outputs. Outputs are generated by transactions that unlock and consume existing outputs (which actually turn into inputs when consumed by a transaction) and generate new outputs. At pruning time consumed outputs will be removed by Nodes. However they might be stored permanently by Nodes counting with an INX Chronicle plugin. Each output in the Ledger has a unique identifier as it has each transaction.

## Storage cost

UTXOs need to be stored by Hornet Nodes, thus there is a storage cost. The Stardust protocol defines a parameter, named "vByte cost", that defines, in *Glows*, the cost of storage of each "virtual byte". As each output consumes a number of vBytes in the Ledger, it is a necessary condition for an output to cover with its value at least the vByte cost in the Ledger. This means that Nodes will reject, upfront, transactions which outputs do not meet this condition. For instance, in the current Shimmer network, you cannot just transact 1 Glow to a new output because the storage cost of such an output will be higher. And that's when it comes into play *storage deposits* that will be introduced later on.

The size of a UTXO and thus its cost depends structurally on its type but also on additional data it may carry out as we will be showing lately.

## Preparing the experimentation environment

In order to run a similar code than the one explained by this tutorial you need:

* Node.js 16
* The `@iota/iota.js` library package, version xx.
* Auxiliary libraries, `@iota/crypto.js` `@iota/util.js`
* Access to a Stardust Node (Hornet 2.0.0), for instance, the Shimmer testnet Nodes at []().
* To run the PoW computation it would be advisable to count with the Neon-Pow package. Another alternative is that you spin out your own Node configured to perform the PoW remotely.
* If you decide to use TypeScript then also the TypeScript compiler and so on

An example `package.json` file is shown below:

```json
{
    "name": "tutorial",
    "version": "1.0.0",
    "scripts": {
        "dist": "tsc",
        "start": "node dist/index"
    },
    "dependencies": {
        "@iota/crypto.js": "2.0.0-rc.1",
        "@iota/iota.js": "2.0.0-rc.1",
        "@iota/util.js": "2.0.0-rc.1",
        "@iota/pow-neon.js": "2.0.0-rc.2"
    },
    "devDependencies": {
        "typescript": "^4.4.3",
        "@types/node": "18.7.23"
    }
}
```

## Generating addresses

In order to start transacting in the network it is needed to count with one or more addresses that can unlock outputs or receive new outputs. Addresses are derived from a public key and their outputs can be unlocked with the corresponding private key. As it happens with Firefly the idea is to be able to generate multiple addresses starting with an initial master secret (seed phrase) and from that point on use a hierarchical deterministic method to derive the different addresses.

### Generating a seed phrase and an Ed25519 seed

The seed phrase is generated in accordance with the [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) specification and it is composed by a set of words, represented as whitespace-separated string.

```typescript
    // Default entropy length is 256
    const randomMnemonic = Bip39.randomMnemonic();

    console.log("Seed phrase:", randomMnemonic);
```

Once you have the seed phrase (BIP 39 random mnemonic) the next step is to obtain a Ed25519 master seed from the seed phrase:

```typescript
 const masterSeed = Ed25519Seed.fromMnemonic(randomMnemonic);
```

This master seed will be used later to generate the Ed25519 key pairs through the BIP32 method.

### Deterministic address paths (Bip32)

This master seed can be used to generate, in a deterministic manner, addresses i.e. Ed25519 key pairs, generated through the [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) method and structured as per the [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) logical hierarchy. The iota.js library provides a method `generateBip44Address` that creates these BIP32 paths using an state object that it is updated on each call made.

```typescript
const addressGeneratorAccountState = {
    accountIndex: 0,
    addressIndex: 0,
    isInternal: false
};
const paths: string[] = [];
for (let i = 0; i < 6; i++) {
    const path = generateBip44Address(addressGeneratorAccountState);
    paths.put(path);

    console.log(`${path}`);
}
```

That will generate the following BIP32 paths:

```text
m/44'/4218'/0'/0'/0'
m/44'/4218'/0'/1'/0'
m/44'/4218'/0'/0'/1'
m/44'/4218'/0'/1'/1'
m/44'/4218'/0'/0'/2'
m/44'/4218'/0'/1'/2'
```

* `44` is a constant that denotes *purpose*, (`0x8000002C`) following the [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) recommendation.
* `4218` is the *coin type* for Shimmer
* the three following numbers are:

* the *account index*, as users can use these accounts to organize the funds in the same fashion as bank accounts; for donation purposes (where all addresses are considered public), for saving purposes, for common expenses etc.
* the *change index*, that allows to separate addresses used for external operations (ex. receive funds) or just for internal operations (ex. generate change).
* the *address index* that increments sequentially

In the example above it has been generated `6` address paths, for the account `0` and from index `0` to `2`, starting with one address for external operations and then alternating with another address for internal operations.

### Ed25519 key pairs for the addresses

For generating a Ed25519 key fair first of all it is needed to generate a subsequent Ed25519 seed from a BIP32 path and from that point on the key pair can be derived.

```typescript
const keyPairs: IKeyPair[] = [];

for (const path of paths) {
    // Master seed was generated previously
    const addressSeed = masterSeed.generateSeedFromPath(new Bip32Path(path));
    const addressKeyPair = addressSeed.keyPair();
    keyPairs.push(addressKeyPair);

    console.log(Converter.bytesToHex(addressKeyPair.privateKey, true));
    console.log(Converter.bytesToHex(addressKeyPair.publicKey, true));
}
```

As the keys are generated as byte arrays (`UInt8Array`) it is necessary to encode them using displayable characters, in this case,  hexadecimal characters. The trailing `true` parameter indicates that the `0x` prefix shall be included in the representation.

You can observe that they key pairs generated are of the form:

`0x6f0fa2f7a9d5fbd221c20f54d944378acb871dcdeafc3761e73d7f0aa05c75356f8eeee559daa287ec40a3a7113e88df2fc27bc77819e6d3d146a7dc7a4e939c`
`0x6f8eeee559daa287ec40a3a7113e88df2fc27bc77819e6d3d146a7dc7a4e939c`

The Ed25519 private key contains `128` hex chars that corresponds to `64` bytes. Conversely, the public key can be represented using `64` hex chars i.e. `32` bytes.

At this point in time we have our asymmetric cryptography set but we need to generate the final addresses that will be used in the Shimmer network.

## Final addresses

As it usually happens in Blockchain, the addresses used are derived from a public key by hashing it. In the case of Stardust, they are derived from the Ed25519 public key.

There are two different address formats:

* the Ed25519 format (which it is just a hash of the Ed25519 public key)

* an easy to be identified and error resistant format which complies with [BECH32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki). In the case of Shimmer the BECH32 human readable part (HRP) used is `smr`, whereas `rms` is used for the testnet. Those HRPs are also provided as metadata elements of the `info` primitive of the protocol (more on this later)

```typescript
const finalAddresses: { ed25519: string, bech32: string }[] = [];

for (const keyPair of keyPairs) {
    const ed25519Address = new Ed25519Address(keyPair.publicKey);
    // Address in bytes
    const publicKeyAddress = ed25519Address.toAddress();
    // Conversion to BECH32
    const bech32Addr = Bech32Helper.toBech32(ED25519_ADDRESS_TYPE, publicKeyAddress, "rms");

    const finalAddress = {
        ed25519: Converter.bytesToHex(publicKeyAddress, true),
        bech32: bech32Addr
    };
    finalAddresses.push(finalAddress);

    console.log(finalAddress);
}
```

You can observe that the BECH32 address is generated from the Ed25519 address which it is a hash of the public key. 

Resulting in:

```text
{
  ed25519: '0x1696e3735e8871ce7086af6a9920e1a3b83cdf8b265adf449fc4bda86b91e2bb',
  bech32: 'rms1qqtfdcmnt6y8rnnss6hk4xfqux3ms0xl3vn94h6ynlztm2rtj83tk9qkzrx'
}
```

You can observe that the Ed25519 format has a length of `64` hex chars (32 bytes) as the Ed25519 public key. On the other hand the BECH32 address starts with `rms` or `smr` and continues with a `1` character.

At any point in time it is possible to transform the BECH32 address into a Ed25519 address as follows:

```typescript
const ed25519Addr = Bech32Helper.fromBech32(bech32Address, "rms").addressBytes;
```

## Issuing a Value Transaction

### Sending funds to an initial address

Once we have a set of addresses and in order to experiment with value transactions it is necessary to have some funds. We are going to do our experiments with the testnet and request some initial funds to the [testnet Shimmer faucet](https://faucet.testnet.shimmer.network/). 